## 목차
[6.1 객체 지향 프로그래밍](#61-객체-지향-프로그래밍)   
[6.2 객체와 클래스](#62-객체와-클래스)   
[6.3 클래스 선언](#63-클래스-선언)   
[6.4 객체 생성과 클래스 변수](#64-객체-생성과-클래스-변수)   
[6.5 클래스의 구성 멤버](#65-클래스의-구성-멤버)   
[6.6 필드](#66-필드)   
[6.7 생성자(1)](#67-생성자1)   
[6.7 생성자(2)](#67-생성자2)   
[6.8 메소드(1)](#68-메소드1)   
[6.8 메소드(2)](#68-메소드2)   
[6.8 메소드(3)](#68-메소드3)   
[6.9 인스턴스 멤버와 this](#69-인스턴스-멤버와-this)   
[6.10 정적 멤버와 static(1)](#610-정적-멤버와-static1)   
[6.10 정적 멤버와 static(2)](#610-정적-멤버와-static2)   
[6.11 final 필드와 상수](#611-final-필드와-상수)   
[6.12 패키지(1)](#612-패키지1)   

## **6.1 객체 지향 프로그래밍**

- 자바로 객체 지향 프로그래밍을 작성하기 위해서는 클래스부터 선언해야 함

![Untitled](./images/6.png)

- 객체지향 프로그래밍: 자동차를 만들 때, 타이어 객체, 엔진 객체, 문 객체, 핸들 객체를 합쳐 만드는 것처럼, 각 부품 객체들을 조립해 완성된 프로그램을 만드는 것
- 객체: 속성과 동작을 가지는 모든 것
- 자바 객체: 필드(속성), 메서드(동작)으로 구성됨
- 객체 모델링: 현실 세계를 소프트웨어 객체로 변환하는 것

![Untitled](./images/6(1).png)

![Untitled](./images/6(2).png)

- 집합 관계: “어떤 부품들이 모여 완성품이 만들어진다”
    - 엔진 객체, 타이어 객체, 핸들 객체 → 자동차 객체
- 사용 관계: “어떤 객체가 어떤 객체의 메서드를 호출해서 사용한다”
    - 사람이 → 자동차를 사용
- 상속 관계: “어떤 객체가 어떤 객체의 내용을 물려받아서 사용한다”
    - 자동차 객체는 → 기계 객체의 데이터(속성, 동작)을 사용할 수 있음

![Untitled](./images/6(3).png)

- 실제 필드와 메서드를 외부로부터 보이지 않게 구조를 숨김
- 몇 가지 필드와 메서드만 외부에 제공

![Untitled](./images/6(4).png)

![Untitled](./images/6(5).png)

- 객체의 부품화: 그때그때 객체를 바꿔 끼워 사용할 수 있음
- 다형성: 설계할 때 타입은 ‘타이어’로 모두 동일하지만, 실제 구현 객체는 ‘타이어의 하위 객체’인 한국 타이어, 금호 타이어로, 실행 결과가 다양하게 나올 수 있음

## **6.2 객체와 클래스**

![Untitled](./images/6(6).png)

## **6.3 클래스 선언**

![Untitled](./images/6(7).png)

![Untitled](./images/6(8).png)

- 2개 이상의 Class가 선언된 소스 파일을 컴파일 하면, 선언된 Class 개수만큼 바이트 코드 파일 생성됨
- 하나의 소스 파일은 Class들을 담고 있는 그릇 역할만 하고, 컴파일 되어 나오는 바이트 코드 파일의 수는 Class의 수가 결정함

## **6.4 객체 생성과 클래스 변수**

![Untitled](./images/6(9).png)

- new 연산자로 생성된 클래스 객체는 힙 영역에 위치
- new 연산자는 힙 영역에 생성된 객체의 번지를 리턴하고, 이 번지가 스택 영역에 선언된 클래스 변수에 저장됨

![Untitled](./images/6(10).png)

- 클래스 용도
    - 1) 라이브러리
        - 클래스를 작성할 때, main() 메서드를 넣지 않고 필드, 생성자, 메서드 내용으로만 클래스를 작성하게 되면 그 클래스는 실행할 수 없는 클래스가 됨
        - 라이브러리용 클래스는 반드시 객체를 생성한 후 사용해야 함(정적 필드, 정적 메서드 제외)
        - 예) Student 객체
    - 2) 실행용: main()

## **6.5 클래스의 구성 멤버**

![Untitled](./images/6(11).png)

- 생성자
    - 객체 생성. 초기화 담당. `실행 블록({})`을 가짐.
    - `new 생성자();` 로 생성자를 호출하므로, 이때 생성자의 `{}`이 실행되고, 블록이 끝나는 시점에서 객체가 완성됨.
    - 리턴 타입이 없음
- 메서드: void 외 리턴 타입을 반드시 지정해야 함

## **6.6 필드**

![Untitled](./images/6(12).png)

![Untitled](./images/6(13).png)

![Untitled](./images/6(14).png)

![Untitled](./images/6(15).png)

## **6.7 생성자(1)**

![Untitled](./images/6(16).png)

![Untitled](./images/6(17).png)

![Untitled](./images/6(18).png)

![Untitled](./images/6(19).png)

![Untitled](./images/6(20).png)

## **6.7 생성자(2)**

![Untitled](./images/6(21).png)

![생성자 코드 중복의 예시](./images/6(22).png)

생성자 코드 중복의 예시

![Untitled](./images/6(23).png)

- 중복 코드를 피하는 방법: this() 사용
- this(): 객체의 다른 생성자를 지칭, 즉 자신의 다른 생성자를 지칭

```java
Car(String model, String color, int maxSpeed) {
	this.model = model;
	this.color = color;
	this.maxSpeed = maxSpeed;
}
// (1) 공통 실행 코드를 작성해 놓고, this()로 이 코드를 호출함

Car(String model) { // (2)
	this(model, null, 0); // 생성자를 호출만 함(매개변수 외의 값은 기본값)
// 즉, (2)는내부적으로 (1)에 선언한 생성자를 실행하는 것
}
```

- this()는 생성자의 가장 첫 줄에 작성되어야 함

```java
// 올바른 예
Car(String model) {
	this(model, null, 0);
	System.out.println();
}
```

```java
// 올바르지 않은 예
Car(String model) {
	System.out.println();
	this(model, null, 0);
}
```

## **6.8 메소드(1)**

![Untitled](./images/6(24).png)

![Untitled](./images/6(25).png)

![Untitled](./images/6(26).png)

![Untitled](./images/6(27).png)

## **6.8 메소드(2)**

![Untitled](./images/6(28).png)

![Untitled](./images/6(29).png)

## **6.8 메소드(3)**

![Untitled](./images/6(30).png)

![Untitled](./images/6(31).png)

![Untitled](./images/6(32).png)

- method1()을 double타입으로 받으면 double로 자동 타입 전환됨

![Untitled](./images/6(33).png)

![Untitled](./images/6(34).png)

## **6.9 인스턴스 멤버와 this**

![Untitled](./images/6(35).png)
- int gas, setSpeed() 코드가 Car 객체 안에 들어갈까? ⇒ No
    - Car 객체 안에 gas 필드를 저장하는 공간이 생기고, setSpeed()를 호출할 수 있다는 뜻이지, 메서드 코드가 객체 안에 들어가지는 않음
    - 메서드 코드는 메서드 영역에 위치함(메서드 호출은 객체를 통해 함)

![Untitled](./images/6(36).png)

- this는 heap 객체 내부에 생성됨
- this는 객체 내부에서 자신의 위치 정보 값을 저장하고 있음
- this.field: 객체가 가지고 있는 필드

## **6.10 정적 멤버와 static(1)**

![Untitled](./images/6(37).png)

- 인스턴스 멤버: 객체에 소속
- 정적 멤버
    - 클래스에 소속
    - 객체 내부에 존재하지 않음, 메소드 영역(클래스의 바이트 코드가 있는)에 존재함
    - 객체 안에 존재하지 않기에, 객체를 만들지 않아도 됨
    - 클래스만 가지고도 정적 멤버 사용 가능
- static이 있으면 정적 멤버, 없으면 인스턴스 멤버
- static이 붙게 되면, 이 클래스를 JVM에 속해있는 클래스 로더가 컴파일된 바이트 코드를 읽어 메소드 영역에 적재시킴
- 이때, 바이트 코드의 내용을 분석해서 정적 필드, 정적 메소드를 메소드 영역에 위치시킴
- 정적 필드와 정적 메서드는 객체를 만들 때 그 안에 들어가는 것이 아니라, 메서드 영역에 위치하며, 정적 필드에 데이터가 저장되기도 하며, 정적 메서드가 실행되기도 함
- 즉, 정적 필드와 정적 메서드는 객체 안에 저장되지 않고, 메서드 영역 한 곳에만 고정되어 있음

![Untitled](./images/6(38).png)

- 인스턴스 멤버를 new 연산자로 접근하는 것과는 달리, 정적 멤버는 클래스 이름과 도트 연산자로 접근
- 예를 들어, Calculator의 static double pi, static int plus, static int minus는 정적 멤버이므로 만들어진 객체마다 가지는 것이 아니라,  클래스 바이트 코드와 함께 메서드 영역의 고정된 위치에 저장됨
- static 키워드는 공통적인 의미를 가지고 있고, 객체마다 공유해서 쓸 수 있음

![Untitled](./images/6(39).png)

- 메서드 영역에 있는 정적 멤버들을 힙 영역의 객체들을 통해 사용할 수 있음
- 원래는 클래스 이름을 통해서 접근해야 하지만, 객체들을 통해서도 접근할 수도 있다는 말
- 하지만, 어디서나 가능하다는 얘기지 클래스가 아닌 객체를 통해 정적 멤버에 접근하는 것은 바람직하지 않음- 
- **[바른 사용]: 메서드 영역의 Calculator클래스 에서 바로 pi, plus, minus 사용하기**

![Untitled](./images/6(40).png)

![Untitled](./images/6(41).png)

- static int x = 10; static String company = “삼성”; 과 같이 단순하지 않은 복잡한 초기화 식은 정적 초기화 블록 안에서 실행

```java
class Test {
	int x = 10;
	int y;
	Test() {
		y = 20; // 생성자 내에서 복잡한 필드값을 줄 때
	}
	// static 필드는 생성자 내에서 초기화 할 수 없음
	// 생성자는 객체를 생성할 때 실행하므로 객체와 관련있음 
	// static은 객체 안에 들어가는 게 아니기 때문에 생성자 안에서 초기화하지 못함
}
```

- static은 객체 안에 들어가는 게 아니기 때문에 생성자 안에서 초기화하지 못함 ⇒ 생성자는 객체를 생성할 때 실행되는 것이므로

```java
class Test {
	static int x;
	static {
		x = 10; // 이런 식으로 static 필드 초기화 가능(for문 등도 가능)
	}
	// 정적 필드 초기화, 정적 메서드 호출 가능
	// 인스턴스 필드, 인스턴스 메서드 호출 불가능
}
```

- static 블록은 클래스가 메모리로 로딩될 때, 즉 메서드 영역으로 들어올 때 자동으로 실행됨
    - 정적 필드 초기화, 정적 메서드 호출 가능
    - 인스턴스 필드, 인스턴스 메서드 호출 불가능

![Untitled](./images/6(42).png)

- 여러 개의 static 블록 선언 가능(순차적으로 실행)

## **6.10 정적 멤버와 static(2)**

![Untitled](./images/6(43).png)

- static 블록에서는 인스턴스 멤버를 사용할 수 없음
- 그래서, 위 예시처럼 field1, method1()을 static에 넣을 수 없음
- 마찬가지로, 객체 자신을 참조하는 this도 사용할 수 없음

![Untitled](./images/6(44).png)

- 객체를 생성한 후에는 사용할 수 있음 ⇒ obj가 참조하는 객체
- 즉, static void Method() 처럼 객체를 만들고 인스턴스 필드를 사용하는 것은 가능

![Untitled](./images/6(45).png)

- main() 메서드도 정적 메서드
- 객체가 있어야 그 안의 인스턴스 멤버를 사용할 수 있으므로, 위의 예시처럼 main() 메서드에 Car 객체를 생성해서 사용함

![Untitled](./images/6(46).png)

- 단 하나의 객체를 만들어야 하는 경우, new로 객체를 만들지 못하도록 함
    1. private 접근 제한자를 생성자 앞에 붙임
    2. private 접근 제한자를 필드값 앞에 붙임
    3. 정적 메서드 getInstance() 선언
        1. getInstance()는 자기 자신의 객체 리턴
        2. 자기 자신의 필드에 대입된 객체, 즉 필드가 참조하는 객체를 리턴
        3. getInstance() 메서드가 몇 번을 실행되던 자기 자신의 필드에 대입된 단 하나의 new 객체만 리턴함
- 즉, 외부에서는 싱글톤 객체를 new 연산자를 통해 호출할 수 없음
- 반드시 getInstance()를 통해서만 호출 가능
- getInstance() 메서드는 자기 자신 필드가 참조하는 항상 하나의 객체만 리턴함

![Untitled](./images/6(47).png)

<aside>
💡 **내용정리!**

> 메서드 영역의 Singleton 필드가 → 힙 영역에 만들어진 객체 new Singleton()을 참조하고,   
> 스택 영역에 만들어진 Singleton obj1 변수가 → 힙 영역의 유일한 객체 new Singleton()을 참조하는 듯   
> 그런데 Singleton 필드는 private이라 외부에서 불러올 수 없으니,   
> static getInstance() 메서드를 만들어서 외부에서 이것만 호출할 수 있도록 하는 듯   
</aside>

- 싱글톤 객체의 getInstance() 메서드는 static이기 때문에 클래스로 접근 가능
- private 때문에 외부에서 접근할 수 없기 때문에, `Singleton obj1 = new Singleton();` 과 같은 코드는 오류가 남
- **애플리케이션 전체에서 싱글톤 객체는 딱 하나만 만들어짐**
- [싱글톤에 대한 더 자세한 설명](https://roadofdevelopment.tistory.com/19)

## **6.11 final 필드와 상수**

![Untitled](./images/6(48).png)

- `final String ssn;` 와 같이 변수 선언 후 나중에 값을 줄 경우, 생성자로만 딱 한번의 초기값을 지정할 수 있음
- 생성자로 `this.ssn = ssn;` 으로 값을 한번 대입시킨 후에는 값을 변경할 수 없음

![Untitled](./images/6(49).png)

- final 필드: 객체마다 가지는 불변 필드
- 상수
    - 객체마다 가지고 있는 게 아니고, 메서드 영역의 상수 area에 저장됨
    - 보통 대문자로 변수 선언
    - 선언과 동시에 초기값을 주거나, `static final 타입 상수;`와 같이 변수만 선언 후 static 블록에 딱 한 번 초기값 설정 가능

## **6.12 패키지(1)**